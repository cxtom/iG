<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>sat-test</title>
        <style type="text/css">
            html,
            body {
                margin: 0;
                padding: 0;
            }
            canvas {
                display: block;
                border: 1px solid #ddd;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <script>

            /**
             * 使用分离轴定理 (Separating Axis Theorem) 检测形状是否相交
             */
            (function (window, SAT) {

                var abs = Math.abs;
                var sqrt = Math.sqrt;

                /**
                 * 二维向量
                 *
                 * @param {number} x x
                 * @param {number} y y
                 * @constructor
                 */
                var Vector = function (x, y) {
                    this.x = x || 0;
                    this.y = y || x || 0;
                };
                SAT.Vector = Vector;

                /**
                 * 向量的复制，把待复制的向量复制到当前向量的实例
                 *
                 * @param {Object} other 待复制的向量
                 *
                 * @return {Object} 当前向量实例
                 */
                Vector.prototype.copy = function (other) {
                    this.x = other.x;
                    this.y = other.y;
                    return this;
                };

                /**
                 * 将向量旋转 90 度
                 *
                 * @return {Object} 当前向量实例
                 */
                Vector.prototype.perp = function () {
                    var x = this.x;
                    this.x = this.y;
                    this.y = -x;
                    return this;
                };

                /**
                 * 向量反转
                 *
                 * @return {Object} 当前向量实例
                 */
                Vector.prototype.reverse = function () {
                    this.x = -this.x;
                    this.y = -this.y;
                    return this;
                };

                /**
                 * 归一化单位长度
                 *
                 * @return {Object} 当前向量实例
                 */
                Vector.prototype.normalize = function () {
                    var len = this.len();
                    if (len > 0) {
                        this.x = this.x / len;
                        this.y = this.y / len;
                    }
                    return this;
                };

                /**
                 * 向量相加
                 *
                 * @param {Object} 待加向量
                 *
                 * @return {Object} 当前向量实例
                 */
                Vector.prototype.add = function (other) {
                    this.x += other.x;
                    this.y += other.y;
                    return this;
                };

                /**
                 * 向量相减
                 *
                 * @param {Object} 待减向量
                 *
                 * @return {Object} 当前向量实例
                 */
                Vector.prototype.sub = function (other) {
                    this.x -= other.x;
                    this.y -= other.y;
                    return this;
                };

                /**
                 * 向量缩放
                 *
                 * @param {number} x x 方向缩放因子
                 * @param {number} y y 方向缩放因子，如果未设置，那么使用 x 方向的
                 *
                 * @return {Object} 当前向量实例
                 */
                Vector.prototype.scale = function (x, y) {
                    this.x *= x;
                    this.y *= y || x;
                    return this;
                };

                /**
                 * 当前向量投射到另一个向量
                 *
                 * @param {Object} other 投射到的目标向量
                 *
                 * @return {Object} 当前向量实例
                 */
                Vector.prototype.project = function (other) {
                    var amt = this.dot(other) / other.len2();
                    this.x = amt * other.x;
                    this.y = amt * other.y;
                    return this;
                };

                /**
                 * 当前向量投射到另一个向量，单位长度
                 *
                 * @param {Object} other 投射到的目标向量
                 *
                 * @return {Object} 当前向量实例
                 */
                Vector.prototype.projectN = function (other) {
                    var amt = this.dot(other);
                    this.x = amt * other.x;
                    this.y = amt * other.y;
                    return this;
                };

                /**
                 * 在轴上反映该向量
                 *
                 * @param {Object} axis 轴表示的向量
                 *
                 * @return {Object} 当前向量实例
                 */
                Vector.prototype.reflect = function (axis) {
                    var x = this.x;
                    var y = this.y;

                    this.project(axis).scale(2);
                    this.x -= x;
                    this.y -= y;
                    return this;
                };

                /**
                 * 在轴上反映该向量（单位向量）
                 *
                 * @param {Object} axis 轴表示的单位向量
                 *
                 * @return {Object} 当前向量实例
                 */
                Vector.prototype.reflectN = function (axis) {
                    var x = this.x;
                    var y = this.y;

                    this.projectN(axis).scale(2);
                    this.x -= x;
                    this.y -= y;
                    return this;
                };

                /**
                 * 当前向量和另一个向量的点积
                 *
                 * @param {Object}  另一个向量
                 *
                 * @return {number} 点积
                 */
                Vector.prototype.dot = function (other) {
                    return this.x * other.x + this.y * other.y;
                };

                /**
                 * 获取当前向量本身的点积
                 *
                 * @return {number} 当前向量本身的点积
                 */
                Vector.prototype.len2 = function () {
                    return this.dot(this);
                };

                /**
                 * 获取向量的长度
                 * A · B = |A| * |B| * Cos(angle)  angle 为向量 A 和向量 B 的夹角值
                 * |A| 为向量 A 的模即长度，二维空间中 |A| = sqrt(x * x + y * y)
                 *
                 * @return {number} 向量的长度
                 */
                Vector.prototype.len = function () {
                    return sqrt(this.len2());
                };

                /**
                 * A circle.
                 *
                 * @param {Vector} pos 圆心
                 * @param {Number} r 半径
                 * @constructor
                 */
                var Circle = function (pos, r) {
                    this.pos = pos || new Vector();
                    this.r = r || 0;
                };
                SAT.Circle = Circle;

                /**
                 * 顺时针方向凸多边形
                 *
                 * @param {Vector} pos 多边形的原点（其他的 points 都是相对于这个点的）
                 * @param {Array.<Vector>} points 多边形中的点的序列，顺时针方向
                 *
                 * @constructor
                 */
                var Polygon = function (pos, points) {
                    this.pos = pos || new Vector();
                    this.points = points || [];
                    this.recalc();
                };
                SAT.Polygon = Polygon;

                /**
                 * 重新计算多边形的边和法线，当多边形的点序列被改变以及获取边或法线时被调用
                 */
                Polygon.prototype.recalc = function () {
                    var points = this.points;
                    var len = points.length;
                    this.edges = [];
                    this.normals = [];
                    for (var i = 0; i < len; i++) {
                        var p1 = points[i];
                        var p2 = i < len - 1 ? points[i + 1] : points[0];
                        var e = new Vector().copy(p2).sub(p1);
                        var n = new Vector().copy(e).perp().normalize();
                        this.edges.push(e);
                        this.normals.push(n);
                    }
                };

                /**
                 * 轴对齐的盒，具有高宽
                 *
                 * @param {Vector} pos 盒子左上角的点（向量）
                 * @param {number} w 宽度
                 * @param {number} h 高度
                 *
                 * @constructor
                 */
                var Box = function (pos, w, h) {
                    this.pos = pos || new Vector();
                    this.w = w || 0;
                    this.h = h || w || 0;
                };
                SAT.Box = Box;

                /**
                 * 创建一个和 box 一样的多边形
                 *
                 * @return {Polygon} 创建出来的多边形
                 */
                Box.prototype.toPolygon = function () {
                    var pos = this.pos;
                    var w = this.w;
                    var h = this.h;
                    return new Polygon(new Vector(pos.x, pos.y), [
                        new Vector(),
                        new Vector(w, 0),
                        new Vector(w, h),
                        new Vector(0, h)
                    ]);
                };

                /**
                 * Pool of Vectors used in calculations.
                 *
                 * @type {Array}
                 */
                var T_VECTORS = [];
                for (var i = 0; i < 10; i++) {
                    T_VECTORS.push(new Vector());
                }

                /**
                 * Pool of Arrays used in calculations.
                 *
                 * @type {Array}
                 */
                var T_ARRAYS = [];
                for (var i = 0; i < 5; i++) {
                    T_ARRAYS.push([]);
                }

                /**
                 * 交集的结果
                 *     1. 参与相交的两个对象
                 *     2. 从一个对象中提取另一个对象的所需的最小变化
                 *     3. 一个对象是否完全在另一个对象内部，或者相反
                 *
                 * @constructor
                 */
                var Response = function () {
                    this.a = null;
                    this.b = null;
                    this.overlapN = new Vector(); // 重叠方向的单位向量
                    this.overlapV = new Vector(); // 重叠的面积即重叠的大小
                    this.clear();
                };
                SAT.Response = Response;

                /**
                 * 重置默认值，重用一个 Response 实例对象为多个相交测试
                 *
                 * @return {Response} Response 实例
                 */
                Response.prototype.clear = function () {
                    this.aInB = true; // a 完全在 b 里面
                    this.bInA = true; // b 完全在 a 里面
                    this.overlap = Number.MAX_VALUE; // 两个对象相交的面积（this.overlapV 的值），如果两个对象刚刚碰到那么就是 0
                    return this;
                };

                /**
                 * Flattens the specified array of points onto a unit vector axis,
                 * resulting in a one dimensional range of the minimum and
                 * maximum value on that axis.
                 *
                 * @param {Array.<Vector>} points The points to flatten.
                 * @param {Vector} normal The unit vector axis to flatten on.
                 * @param {Array.<number>} result An array.  After calling this function,
                 *   result[0] will be the minimum value,
                 *   result[1] will be the maximum value.
                 */
                var flattenPointsOn = function (points, normal, result) {
                    var min = Number.MAX_VALUE;
                    var max = -Number.MAX_VALUE;
                    var i = points.length;
                    while (i--) {
                        // Get the magnitude of the projection of the point onto the normal
                        var dot = points[i].dot(normal);
                        if (dot < min) min = dot;
                        if (dot > max) max = dot;
                    }
                    result[0] = min;
                    result[1] = max;
                };

                /**
                 * Check whether two convex clockwise polygons are separated by the specified
                 * axis (must be a unit vector).
                 *
                 * @param {Vector} aPos The position of the first polygon.
                 * @param {Vector} bPos The position of the second polygon.
                 * @param {Array.<Vector>} aPoints The points in the first polygon.
                 * @param {Array.<Vector>} bPoints The points in the second polygon.
                 * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons
                 *   will be projected onto this axis.
                 * @param {Response=} response A Response object (optional) which will be populated
                 *   if the axis is not a separating axis.
                 * @return {boolean} true if it is a separating axis, false otherwise.  If false,
                 *   and a response is passed in, information about how much overlap and
                 *   the direction of the overlap will be populated.
                 */
                var isSeparatingAxis = function (aPos, bPos, aPoints, bPoints, axis, response) {
                    var rangeA = T_ARRAYS.pop();
                    var rangeB = T_ARRAYS.pop();

                    // Get the magnitude of the offset between the two polygons
                    var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);
                    var projectedOffset = offsetV.dot(axis);

                    // Project the polygons onto the axis.
                    flattenPointsOn(aPoints, axis, rangeA);
                    flattenPointsOn(bPoints, axis, rangeB);

                    // Move B's range to its position relative to A.
                    rangeB[0] += projectedOffset;
                    rangeB[1] += projectedOffset;

                    // Check if there is a gap. If there is, this is a separating axis and we can stop
                    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {
                        T_VECTORS.push(offsetV);
                        T_ARRAYS.push(rangeA);
                        T_ARRAYS.push(rangeB);
                        return true;
                    }

                    // If we're calculating a response, calculate the overlap.
                    if (response) {
                        var overlap = 0;
                        // A starts further left than B
                        if (rangeA[0] < rangeB[0]) {
                            response.aInB = false;
                            // A ends before B does. We have to pull A out of B
                            if (rangeA[1] < rangeB[1]) {
                                overlap = rangeA[1] - rangeB[0];
                                response.bInA = false;
                                // B is fully inside A.  Pick the shortest way out.
                            } else {
                                var option1 = rangeA[1] - rangeB[0];
                                var option2 = rangeB[1] - rangeA[0];
                                overlap = option1 < option2 ? option1 : -option2;
                            }
                            // B starts further left than A
                        } else {
                            response.bInA = false;
                            // B ends before A ends. We have to push A out of B
                            if (rangeA[1] > rangeB[1]) {
                                overlap = rangeA[0] - rangeB[1];
                                response.aInB = false;
                                // A is fully inside B.  Pick the shortest way out.
                            } else {
                                var option1 = rangeA[1] - rangeB[0];
                                var option2 = rangeB[1] - rangeA[0];
                                overlap = option1 < option2 ? option1 : -option2;
                            }
                        }

                        // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.
                        var absOverlap = abs(overlap);
                        if (absOverlap < response.overlap) {
                            response.overlap = absOverlap;
                            response.overlapN.copy(axis);
                            if (overlap < 0) {
                                response.overlapN.reverse();
                            }
                        }
                    }

                    T_VECTORS.push(offsetV);
                    T_ARRAYS.push(rangeA);
                    T_ARRAYS.push(rangeB);
                    return false;
                };

                /**
                 * Calculates which Vornoi region a point is on a line segment.
                 * It is assumed that both the line and the point are relative to (0, 0)
                 *
                 *             |       (0)      |
                 *      (-1)  [0]--------------[1]  (1)
                 *             |       (0)      |
                 *
                 * @param {Vector} line The line segment.
                 * @param {Vector} point The point.
                 * @return {number} LEFT_VORNOI_REGION (-1) if it is the left region,
                 *          MIDDLE_VORNOI_REGION (0) if it is the middle region,
                 *          RIGHT_VORNOI_REGION (1) if it is the right region.
                 */
                var vornoiRegion = function (line, point) {
                    var len2 = line.len2();
                    var dp = point.dot(line);

                    if (dp < 0) return LEFT_VORNOI_REGION;
                    if (dp > len2) return RIGHT_VORNOI_REGION;
                    return MIDDLE_VORNOI_REGION;
                };

                /**
                 * @const
                 */
                var LEFT_VORNOI_REGION = -1;

                /**
                 * @const
                 */
                var MIDDLE_VORNOI_REGION = 0;

                /**
                 * @const
                 */
                var RIGHT_VORNOI_REGION = 1;

                /**
                 * Check if two circles intersect.
                 *
                 * @param {Circle} a The first circle.
                 * @param {Circle} b The second circle.
                 * @param {Response=} response Response object (optional) that will be populated if
                 *   the circles intersect.
                 * @return {boolean} true if the circles intersect, false if they don't.
                 */
                var testCircleCircle = function (a, b, response) {
                    var differenceV = T_VECTORS.pop().copy(b.pos).sub(a.pos);
                    var totalRadius = a.r + b.r;
                    var totalRadiusSq = totalRadius * totalRadius;
                    var distanceSq = differenceV.len2();

                    if (distanceSq > totalRadiusSq) {
                        // They do not intersect
                        T_VECTORS.push(differenceV);
                        return false;
                    }

                    // They intersect. If we're calculating a response, calculate the overlap.
                    if (response) {
                        var dist = sqrt(distanceSq);
                        response.a = a;
                        response.b = b;
                        response.overlap = totalRadius - dist;
                        response.overlapN.copy(differenceV.normalize());
                        response.overlapV.copy(differenceV).scale(response.overlap);
                        response.aInB = a.r <= b.r && dist <= b.r - a.r;
                        response.bInA = b.r <= a.r && dist <= a.r - b.r;
                    }

                    T_VECTORS.push(differenceV);
                    return true;
                };
                SAT.testCircleCircle = testCircleCircle;

                /**
                 * Check if a polygon and a circle intersect.
                 *
                 * @param {Polygon} polygon The polygon.
                 * @param {Circle} circle The circle.
                 * @param {Response=} response Response object (optional) that will be populated if
                 *   they interset.
                 * @return {boolean} true if they intersect, false if they don't.
                 */
                var testPolygonCircle = function (polygon, circle, response) {
                    var circlePos = T_VECTORS.pop().copy(circle.pos).sub(polygon.pos);
                    var radius = circle.r;
                    var radius2 = radius * radius;
                    var points = polygon.points;
                    var len = points.length;
                    var edge = T_VECTORS.pop();
                    var point = T_VECTORS.pop();

                    // For each edge in the polygon
                    for (var i = 0; i < len; i++) {
                        var next = (i === len - 1) ? 0 : i + 1;
                        var prev = (i === 0) ? len - 1 : i - 1;
                        var overlap = 0;
                        var overlapN = null;

                        // Get the edge
                        edge.copy(polygon.edges[i]);

                        // Calculate the center of the cirble relative to the starting point of the edge
                        point.copy(circlePos).sub(points[i]);

                        // If the distance between the center of the circle and the point
                        // is bigger than the radius, the polygon is definitely not fully in
                        // the circle.
                        if (response && point.len2() > radius2) {
                            response.aInB = false;
                        }

                        // Calculate which Vornoi region the center of the circle is in.
                        var region = vornoiRegion(edge, point);
                        if (region === LEFT_VORNOI_REGION) {

                            // Need to make sure we're in the RIGHT_VORNOI_REGION of the previous edge.
                            edge.copy(polygon.edges[prev]);

                            // Calculate the center of the circle relative the starting point of the previous edge
                            var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);

                            region = vornoiRegion(edge, point2);
                            if (region === RIGHT_VORNOI_REGION) {

                                // It's in the region we want.  Check if the circle intersects the point.
                                var dist = point.len();
                                if (dist > radius) {
                                    // No intersection
                                    T_VECTORS.push(circlePos);
                                    T_VECTORS.push(edge);
                                    T_VECTORS.push(point);
                                    T_VECTORS.push(point2);
                                    return false;
                                } else if (response) {
                                    // It intersects, calculate the overlap
                                    response.bInA = false;
                                    overlapN = point.normalize();
                                    overlap = radius - dist;
                                }
                            }
                            T_VECTORS.push(point2);
                        } else if (region === RIGHT_VORNOI_REGION) {

                            // Need to make sure we're in the left region on the next edge
                            edge.copy(polygon.edges[next]);

                            // Calculate the center of the circle relative to the starting point of the next edge
                            point.copy(circlePos).sub(points[next]);

                            region = vornoiRegion(edge, point);
                            if (region === LEFT_VORNOI_REGION) {

                                // It's in the region we want.  Check if the circle intersects the point.
                                var dist = point.len();
                                if (dist > radius) {
                                    // No intersection
                                    T_VECTORS.push(circlePos);
                                    T_VECTORS.push(edge);
                                    T_VECTORS.push(point);
                                    return false;
                                } else if (response) {
                                    // It intersects, calculate the overlap
                                    response.bInA = false;
                                    overlapN = point.normalize();
                                    overlap = radius - dist;
                                }
                            }
                            // MIDDLE_VORNOI_REGION
                        } else {

                            // Need to check if the circle is intersecting the edge,
                            // Change the edge into its "edge normal".
                            var normal = edge.perp().normalize();

                            // Find the perpendicular distance between the center of the
                            // circle and the edge.
                            var dist = point.dot(normal);
                            var distAbs = abs(dist);

                            // If the circle is on the outside of the edge, there is no intersection
                            if (dist > 0 && distAbs > radius) {
                                T_VECTORS.push(circlePos);
                                T_VECTORS.push(normal);
                                T_VECTORS.push(point);
                                return false;
                            } else if (response) {
                                // It intersects, calculate the overlap.
                                overlapN = normal;
                                overlap = radius - dist;
                                // If the center of the circle is on the outside of the edge, or part of the
                                // circle is on the outside, the circle is not fully inside the polygon.
                                if (dist >= 0 || overlap < 2 * radius) {
                                    response.bInA = false;
                                }
                            }
                        }

                        // If this is the smallest overlap we've seen, keep it.
                        // (overlapN may be null if the circle was in the wrong Vornoi region)
                        if (overlapN && response && abs(overlap) < abs(response.overlap)) {
                            response.overlap = overlap;
                            response.overlapN.copy(overlapN);
                        }
                    }

                    // Calculate the final overlap vector - based on the smallest overlap.
                    if (response) {
                        response.a = polygon;
                        response.b = circle;
                        response.overlapV.copy(response.overlapN).scale(response.overlap);
                    }

                    T_VECTORS.push(circlePos);
                    T_VECTORS.push(edge);
                    T_VECTORS.push(point);
                    return true;
                };
                SAT.testPolygonCircle = testPolygonCircle;

                /**
                 * Check if a circle and a polygon intersect.
                 *
                 * NOTE: This runs slightly slower than polygonCircle as it just
                 * runs polygonCircle and reverses everything at the end.
                 *
                 * @param {Circle} circle The circle.
                 * @param {Polygon} polygon The polygon.
                 * @param {Response} response Response object (optional) that will be populated if
                 *   they interset.
                 * @return {boolean} true if they intersect, false if they don't.
                 */
                var testCirclePolygon = function (circle, polygon, response) {
                    var result = testPolygonCircle(polygon, circle, response);
                    if (result && response) {
                        // Swap A and B in the response.
                        var a = response.a;
                        var aInB = response.aInB;
                        response.overlapN.reverse();
                        response.overlapV.reverse();
                        response.a = response.b;
                        response.b = a;
                        response.aInB = response.bInA;
                        response.bInA = aInB;
                    }
                    return result;
                };
                SAT.testCirclePolygon = testCirclePolygon;

                /**
                 * Checks whether two convex, clockwise polygons intersect.
                 *
                 * @param {Polygon} a The first polygon.
                 * @param {Polygon} b The second polygon.
                 * @param {Response} response Response object (optional) that will be populated if
                 *   they interset.
                 * @return {boolean} true if they intersect, false if they don't.
                 */
                var testPolygonPolygon = function (a, b, response) {
                    var aPoints = a.points;
                    var aLen = aPoints.length;
                    var bPoints = b.points;
                    var bLen = bPoints.length;

                    // If any of the edge normals of A is a separating axis, no intersection.
                    while (aLen--) {
                        if (isSeparatingAxis(a.pos, b.pos, aPoints, bPoints, a.normals[aLen], response)) return false;
                    }

                    // If any of the edge normals of B is a separating axis, no intersection.
                    while (bLen--) {
                        if (isSeparatingAxis(a.pos, b.pos, aPoints, bPoints, b.normals[bLen], response)) return false;
                    }

                    // Since none of the edge normals of A or B are a separating axis, there is an intersection
                    // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the
                    // final overlap vector.
                    if (response) {
                        response.a = a;
                        response.b = b;
                        response.overlapV.copy(response.overlapN).scale(response.overlap);
                    }
                    return true;
                };
                SAT.testPolygonPolygon = testPolygonPolygon;

                window.SAT = SAT;
            }(this, {}));

            var canvas = document.getElementById('canvas');
            var ctx = canvas.getContext('2d');
            var width = canvas.width = window.innerWidth;
            var height = canvas.height = window.innerHeight;


            var V = SAT.Vector;
            var P = SAT.Polygon;

            P.prototype.collidesWith = function(polygon, response){
                return SAT.testPolygonPolygon(this, polygon, response);
            };

            P.prototype.draw = function (ctx) {
                var points = this.points;
                var i = points.length;

                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                while (i--) ctx.lineTo(points[i].x, points[i].y);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            };

            /**
             * 最大最小顶点法来渲染矩形包围盒
             */
            P.prototype.drawBounds = function (ctx) {
                var points = this.points;
                var startX = this.pos.x;
                var startY = this.pos.y;

                var minX = Number.MAX_VALUE;
                var maxX = Number.MIN_VALUE;
                var minY = Number.MAX_VALUE;
                var maxY = Number.MIN_VALUE;

                for (var i = 0, len = points.length; i < len; i++) {
                    if (points[i].x < minX) {
                        minX = points[i].x;
                    }
                    if (points[i].x > maxX) {
                        maxX = points[i].x;
                    }
                    if (points[i].y < minY) {
                        minY = points[i].y;
                    }
                    if (points[i].y > maxY) {
                        maxY = points[i].y;
                    }
                }

                // console.warn(minX, maxX, minY, maxY);

                // console.warn(minPoint, maxPoint);
                ctx.strokeStyle = 'green';
                ctx.strokeRect(
                    minX + startX,
                    minY + startY,
                    maxX - minX,
                    maxY - minY
                );
                // debugger


                // ctx.beginPath();
                // ctx.strokeStyle = 'green';
                // ctx.lineWidth = 4;
                // ctx.moveTo(points[0].x + startX, points[0].y + startY);
                // for (var i = 1, len = points.length; i < len; i++) {
                //     ctx.lineTo(points[i].x + startX, points[i].y + startY);
                // }
                // ctx.closePath();
                // ctx.stroke();


                // var points = this.points;
                // var x = points[points.length-1].x;
                // var y = points[points.length-1].y;
                // // console.warn(x, y);
                // var min = x > y ? x : y;
                // var bounds = {
                //     x: points[0].x + this.pos.x,
                //     y: points[0].y + this.pos.y,
                //     w: points[0].x + min,
                //     h: points[0].y + min
                // };

                // ctx.strokeStyle = 'green';
                // ctx.strokeRect(bounds.x, bounds.y, bounds.w, bounds.h);
            };

            console.warn(SAT);
            var pointer = new P(new V(0, 0), [
                new V(0, 0),
                new V(30, 0),
                new V(0, 30)
            ]);

            var polygon = new P(new V(200, 50), [
                new V(0, 0),
                new V(50, 30),
                new V(60, 80),
                new V(50, 100),
                new V(10, 90),
                new V(-20, 30)
            ]);

            var polygon1 = new P(new V(300, 100), [
                new V(5, 5)
                // , new V(100, 50)
                // , new V(50, 100)
                , new V(10, 90)
            ]);

            console.warn(polygon1);

            var C = SAT.Circle;

            C.prototype.collidesWithPolygon = function (polygon, response){
                return SAT.testCirclePolygon(this, polygon, response);
            };

            C.prototype.draw = function (ctx) {
                ctx.save();
                ctx.arc(this.pos.x, this.pos.y, this.r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            };

            C.prototype.drawBounds = function (ctx) {
                ctx.strokeStyle = 'green';
                ctx.strokeRect(
                    this.pos.x - this.r,
                    this.pos.y - this.r,
                    this.r * 2,
                    this.r * 2
                );
            };

            var circle1 = new C(new V(100, 100), 15);


            var B = SAT.Box;

            B.prototype.collidesWithPolygon = function (polygon, response){
                // console.warn(this);
                // console.log(this.toPolygon());
                // return SAT.testPolygonPolygon(this, polygon, response);
                return SAT.testPolygonPolygon(this.toPolygon(), polygon, response);
            };

            B.prototype.draw = function (ctx) {
                ctx.save();
                ctx.fillRect(this.pos.x, this.pos.y, this.w, this.h);
                ctx.fill();
                ctx.restore();
            };

            B.prototype.drawBounds = function (ctx) {
                ctx.strokeStyle = 'green';
                ctx.strokeRect(
                    this.pos.x,
                    this.pos.y,
                    this.w,
                    this.h
                );
            };

            var box1 = new B(new V(200, 200), 100, 100);
            // var box1 = new P(new V(200, 200), [
            //     new V(0, 0),
            //     new V(100, 30),
            //     new V(100, 0),
            //     new V(100, 100),
            //     new V(0, 100)
            // ]);


            var response = new SAT.Response();
            document.onmousemove = function (e) {
                pointer.pos.x = e.pageX;
                pointer.pos.y = e.pageY;

                response.clear();
                var collided = polygon.collidesWith(pointer, response);
                if (collided) {
                    polygon.pos.x -= response.overlapV.x;
                    polygon.pos.y -= response.overlapV.y;
                }

                /////////////////////////////////
                var collided1 = polygon1.collidesWith(pointer, response);
                if (collided1) {
                    polygon1.pos.x -= response.overlapV.x;
                    polygon1.pos.y -= response.overlapV.y;
                }

                var eachCollided = polygon.collidesWith(polygon1, response);
                if (eachCollided) {
                    var minXpolygon1 = Number.MAX_VALUE;
                    var minYpolygon1 = Number.MAX_VALUE;
                    var pointsPolygon1 = polygon1.points;
                    for (var i = 0, len = pointsPolygon1.length; i < len; i++) {
                        if (pointsPolygon1[i].x < minXpolygon1) {
                            minXpolygon1 = pointsPolygon1[i].x;
                        }
                        if (pointsPolygon1[i].y < minYpolygon1) {
                            minYpolygon1 = pointsPolygon1[i].y;
                        }
                    }

                    var minXpolygon = Number.MAX_VALUE;
                    var minYpolygon = Number.MAX_VALUE;
                    var pointsPolygon = polygon.points;
                    for (var i = 0, len = pointsPolygon.length; i < len; i++) {
                        if (pointsPolygon[i].x < minXpolygon) {
                            minXpolygon = pointsPolygon[i].x;
                        }
                        if (pointsPolygon[i].y < minYpolygon) {
                            minYpolygon = pointsPolygon[i].y;
                        }
                    }

                    // 原 polygon 在被碰撞的 polygon 的左边
                    if (minXpolygon < minXpolygon1) {
                        polygon1.pos.x += response.overlapV.x;
                    }
                    else {
                        polygon1.pos.x -= response.overlapV.x;
                    }

                    // 原 polygon 在被碰撞的 polygon 的上边
                    if (minYpolygon < minYpolygon1) {
                        polygon1.pos.y += response.overlapV.y;
                    }
                    else {
                        polygon1.pos.y -= response.overlapV.y;
                    }
                }


                var collidedPolygonAndCircle = circle1.collidesWithPolygon(pointer, response);
                if (collidedPolygonAndCircle) {
                    circle1.pos.x -= response.overlapV.x;
                    circle1.pos.y -= response.overlapV.y;
                }

                var collidedPolygonAndPolygon = box1.collidesWithPolygon(pointer, response);
                if (collidedPolygonAndPolygon) {
                    console.warn(1);
                    // console.warn(response.overlapV.x);
                    box1.pos.x -= response.overlapV.x;
                    box1.pos.y -= response.overlapV.y;
                    // console.warn(box1.pos);
                }
            };

            (function draw() {
                ctx.clearRect(0, 0, width, height);

                ctx.fillStyle = 'red';
                pointer.draw(ctx);
                // pointer.pos.x += Math.floor(Math.random() * 5 + 1);
                // pointer.pos.y += Math.floor(Math.random() * 2 + 1);

                ctx.save();
                ctx.fillStyle = 'black';

                var points = polygon.points;
                var startX = polygon.pos.x;
                var startY = polygon.pos.y;

                var minX = Number.MAX_VALUE;
                var maxX = Number.MIN_VALUE;
                var minY = Number.MAX_VALUE;
                var maxY = Number.MIN_VALUE;

                for (var i = 0, len = points.length; i < len; i++) {
                    if (points[i].x < minX) {
                        minX = points[i].x;
                    }
                    if (points[i].x > maxX) {
                        maxX = points[i].x;
                    }
                    if (points[i].y < minY) {
                        minY = points[i].y;
                    }
                    if (points[i].y > maxY) {
                        maxY = points[i].y;
                    }
                }
                // console.log(
                //     minX + startX,
                //     minY + startY,
                //     maxX - minX,
                //     maxY - minY
                // );


                // ctx.translate(polygon.pos.x, polygon.pos.y);
                // ctx.translate((maxX - minX)/2, (maxY - minY) / 2);
                // ctx.rotate(Math.PI / 180 * 45);
                polygon.draw(ctx);
                ctx.restore();
                polygon.drawBounds(ctx);

                polygon1.draw(ctx);
                polygon1.drawBounds(ctx);

                ctx.fillStyle = 'black';
                circle1.draw(ctx);
                circle1.drawBounds(ctx);

                ctx.fillStyle = 'black';
                box1.draw(ctx);
                box1.drawBounds(ctx);

                setTimeout(draw, 1000 / 60);
            }());
        </script>
    </body>
</html>
