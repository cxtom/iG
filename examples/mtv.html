<!DOCTYPE html>
<html lang="en">
    <head>
        <title>mtv</title>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="HandheldFriendly" content="True">
        <meta name="MobileOptimized" content="320">
        <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
        <meta name="format-detection" content="telephone=no">
        <meta name="apple-mobile-web-app-capable" content="yes"/>
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <meta name="full-screen" content="true"/>
        <meta name="screen-orientation" content="portrait"/>
        <meta name="x5-fullscreen" content="true"/>
        <meta name="360-fullscreen" content="true"/>

        <script type="text/javascript" src="../../build/source/ig-all.js"></script>
        <style type="text/css">
            canvas {
                border: 1px solid #ddd;
            }
        </style>
    </head>
    <body>
        <!-- <ul>
            <li><a href="###">111111</a></li>
        </ul> -->
        <canvas width="800" height="400"></canvas>
        <script type="text/javascript">
            var Vector = ig.Vector;

            var canvas = document.querySelector('canvas');
            var ctx = canvas.getContext('2d');

            /**
             * 把页面上的鼠标坐标换成相对于 canvas 的坐标
             *
             * @param {HTML.Element} canvas canvas 元素
             * @param {number} x 相对于页面的横坐标
             * @param {number} y 相对于页面的纵坐标
             *
             * @return {Object} 相对于 canvas 的坐标对象
             */
            var window2Canvas = function (canvas, x, y) {
                var boundRect = canvas.getBoundingClientRect();
                return {
                    x: Math.round(x - boundRect.left * (canvas.width / boundRect.width)),
                    y: Math.round(y - boundRect.top * (canvas.height / boundRect.height))
                };
            };

            /**
             * 投射对象，用某条轴上的最小值和最大值可表示一段投影
             * 可表示它与另外一段投影是否发生重叠
             */
            var Projection = function (min, max) {
                this.min = min;
                this.max = max;
            };

            Projection.prototype.overlaps = function (projection) {
                return this.max > projection.min && this.min < projection.max;
            };

            /**
             * 最小平移向量
             *
             * @param {[type]} axis [description]
             * @param {[type]} overlap [description]
             */
            var MinTranslationVector = function (axis, overlap) {
                this.axis = axis; // 向量
                this.overlap = overlap; // 标量
            };


            /**
             * 顺时针方向凸多边形
             *
             * @param {Array.<Vector>} points 多边形中的点的序列，顺时针方向
             *
             * @constructor
             */
            var Polygon = function (points) {
                this.points = points || [];
            };

            Polygon.prototype.createPath = function (ctx) {
                var points = this.points;
                var len = points.length;
                if (!len) {
                    return;
                }
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (var i = 0; i < len; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.closePath();
            };

            Polygon.prototype.move = function (dx, dy) {
                var points = this.points;
                var len = points.length;
                for (var i = 0; i < len; i++) {
                    var point = points[i];
                    point.x += dx;
                    point.y += dy;
                }
            };

            Polygon.prototype.stroke = function (ctx) {
                ctx.save();
                this.createPath(ctx);
                ctx.stroke();
                ctx.restore();
            };

            Polygon.prototype.fill = function (ctx) {
                ctx.save();
                this.createPath(ctx);
                ctx.fill();
                ctx.restore();
            };

            Polygon.prototype.getAxes = function () {
                var v1 = new Vector();
                var v2 = new Vector();
                var axes = [];
                for (var i = 0, len = this.points.length - 1; i < len; i++) {
                    v1.x = this.points[i].x;
                    v1.y = this.points[i].y;
                    v2.x = this.points[i + 1].x;
                    v2.y = this.points[i + 1].y;

                    // v1.edge(v2).normal() 指示投影轴的方向
                    axes.push(v1.edge(v2).normal());
                }
                return axes;
            };

            /**
             * 投射多边形上的每个点到指定的轴 (axis)
             */
            Polygon.prototype.project = function (axis) {
                var scalars = [];
                var v = new Vector();
                this.points.forEach(function (point) {
                    v.x = point.x;
                    v.y = point.y;
                    scalars.push(v.dot(axis));
                });
                return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
            };

            Polygon.prototype.collidesWith = function (shape) {

                var axes = shape.getAxes();

                // shape 为圆形
                if (!axes) {
                    return polygonCollidesWidthCircle(this, shape);
                }
                else {
                    axes.concat(this.getAxes());
                    return !this.separationOnAxes(axes, shape);
                }
            };

            Polygon.prototype.separationOnAxes = function (axes, shape) {
                for (var i = 0, len = axes.length; i < len; i++) {
                    var axis = axes[i];
                    var projection1 = shape.project(axis);
                    var projection2 = this.project(axis);
                    if (!projection1.overlaps(projection2)) {
                        return true;
                    }
                }
                return false;
            };

            Polygon.prototype.minTranslationVector = function (axes, shape) {
                var minOverlap = 100000;
                var axisWithMinOverlap = null;
                for (var i = 0, len = axes.length; i < len; i++) {
                    var axis = axes[i];
                    var projection1 = shape.project(axis);
                    var projection2 = this.project(axis);
                    var overlap = projection1.overlap(projection2);

                    // no collision
                    if (overlap === 0) {
                        return {
                            axis: null,
                            overlap: 0
                        }
                    }

                    else {
                        if (overlap < minOverlap) {
                            minOverlap = overlap;
                            axisWithMinOverlap = axis;
                        }
                    }
                }
                return {
                    axis: axisWithMinOverlap,
                    overlap: minOverlap
                };
            };

            Polygon.prototype.isPointInPath = function (ctx, x, y) {
                this.createPath(ctx);
                return ctx.isPointInPath(x, y);
            };

            var Circle = function (x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
            };

            Circle.prototype.createPath = function (ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                ctx.closePath();
            };

            Circle.prototype.move = function (dx, dy) {
                this.x += dx;
                this.y += dy;
            };

            Circle.prototype.stroke = function (ctx) {
                ctx.save();
                this.createPath(ctx);
                ctx.stroke();
                ctx.restore();
            };

            Circle.prototype.fill = function (ctx) {
                ctx.save();
                this.createPath(ctx);
                ctx.fill();
                ctx.restore();
            };

            Circle.prototype.isPointInPath = function (ctx, x, y) {
                this.createPath(ctx);
                return ctx.isPointInPath(x, y);
            };

            /**
             * 圆近似于是有无数条边组成的多边形，因此无法确定投影轴
             *
             * @return {[type]} [description]
             */
            Circle.prototype.getAxes = function () {
                return null;
            };

            Circle.prototype.collidesWith = function (shape) {
                var axes = shape.getAxes();
                var distance;

                // shape 为圆形
                if (!axes) {
                    distance = Math.sqrt(Math.pow(shape.x - this.x, 2) + Math.pow(shape.y - this.y, 2));
                    return distance < Math.abs(this.radius + shape.radius);
                }
                // shape 为多边形
                else {
                    return polygonCollidesWidthCircle(shape, this);
                }
            };

            /**
             * 圆近似于是有无数条边组成的多边形，只需要将圆形投射到一条投影轴
             * 这条投影轴就是圆心与距圆心最近的多边形顶点的连线
             */
            Circle.prototype.project = function (axis) {
                var scalars = [];
                var v = new Vector(this.x, this.y).dot(axis);
                scalars.push(v)
                scalars.push(v + this.radius);
                scalars.push(v - this.radius);
                return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
            };

            function polygonCollidesWithPolygon(p1, p2) {
                var mtv1 = p1.minTranslationVector(p1.getAxes(), p2);
                var mtv2 = p2.minTranslationVector(p2.getAxes(), p2);
                if (mtv1.overlap === 0 && mtv2.overlap === 0) {
                    return {
                        axis: null,
                        overlap: 0
                    }
                }
                else {
                    return mtv1.overlap < mtv2.overlap ? mtv1 : mtv2;
                }
            }

            function circleCollidesWithCircle(c1, c2) {
                var distance = Math.sqrt(Math.pow(c2.x - c1.x, 2) + Math.pow(c2.y - c1.y, 2));
                var overlap = Math.abs(c1.radius + c2.radius) - distance;
                return distance < 0
                    ? new MinTranslationVector(undefined, 0)
                    : new MinTranslationVector(undefined, overlap);
            }

            function polygonCollidesWithCircle(p, c) {
                var axes = p.getAxes();
                var closestPoint = getPolygonPointClosest2Circle(p, c);
                axes.push(getCircleAxis(c, p, closestPoint));
                return p.minTranslationVector(axes, c);
            }

            function getCircleAxis(circle, polygon, closestPoint) {
                var v1 = new Vector(circle.x, circle.y);
                var v2 = new Vector(closestPoint.x, closestPoint.y);
                var surfaceVector = v1.sub(v2);

                return surfaceVector.normalize();
            };

            function getPolygonPointClosest2Circle(polygon, circle) {
                var min = 10000;
                var testPoint;
                var length;
                var closestPoint;
                for (var i = 0, len = polygon.points.length; i < len; i++) {
                    testPoint = polygon.points[i];
                    length = Math.sqrt(Math.pow(testPoint.x - circle.x, 2) + Math.pow(testPoint.y - circle.y, 2))
                    if (length < min) {
                        min = length;
                        closestPoint = testPoint;
                    }
                }
                return closestPoint;
            }

            /**
             * 创建一个投影轴，这个轴连接圆心与距离圆心最近的多边形的顶点
             * 这个轴与多边形返回的其他投影轴一起被用来检测
             */
            function polygonCollidesWidthCircle(polygon, circle) {
                var axes = polygon.getAxes();
                var v1 = new Vector(circle.x, circle.y);
                var closestPoint = getPolygonPointClosest2Circle(polygon, circle);
                var v2 = new Vector(closestPoint.x, closestPoint.y);
                axes.push(v1.sub(v2).normalize());

                return !polygon.separationOnAxes(axes, circle);
            }

            var p1 = new Polygon([
                new Vector(200, 150),
                new Vector(250, 210),
                new Vector(180, 200),
            ]);

            var p2 = new Polygon([
                new Vector(300, 100),
                new Vector(350, 130),
                new Vector(360, 180),
                new Vector(260, 160),
            ]);

            var c1 = new Circle(300, 300, 30);

            var lastDrag = {};
            var beingDragShape = null;

            function detectCollision() {
                console.warn(p1.collidesWith(c1));

                // var shapes = [p1, p2, c1];
                // for (var i = 0, len = shapes.length, shape; i < len; i++) {
                //     shape = shapes[i];
                //     if (shape != beingDragShape) {
                //         console.warn(beingDragShape.collidesWith(shape));
                //     }
                // }
            }

            canvas.onmousedown = function (e) {
                canvas.style.cursor = 'pointer';
                var location = window2Canvas(canvas, e.clientX, e.clientY);
                if (p1.isPointInPath(ctx, location.x, location.y)) {
                    beingDragShape = p1;
                    lastDrag.x = location.x;
                    lastDrag.y = location.y;
                }

                else if (p2.isPointInPath(ctx, location.x, location.y)) {
                    beingDragShape = p2;
                    lastDrag.x = location.x;
                    lastDrag.y = location.y;
                }

                else if (c1.isPointInPath(ctx, location.x, location.y)) {
                    beingDragShape = c1;
                    lastDrag.x = location.x;
                    lastDrag.y = location.y;
                }
            };

            canvas.onmousemove = function (e) {
                if (beingDragShape) {
                    var location = window2Canvas(canvas, e.clientX, e.clientY);
                    var dragVector = {
                        x: location.x - lastDrag.x,
                        y: location.y - lastDrag.y
                    }
                    beingDragShape.move(dragVector.x, dragVector.y);
                    lastDrag.x = location.x;
                    lastDrag.y = location.y;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    p1.stroke(ctx);
                    p2.fill(ctx);
                    c1.stroke(ctx);
                    detectCollision();
                }
            };

            canvas.onmouseup = function () {
                canvas.style.cursor = 'default';
                beingDragShape = null;
            };

            p1.stroke(ctx);
            p2.fill(ctx);
            // debugger
            c1.stroke(ctx);

        </script>
    </body>
</html>
